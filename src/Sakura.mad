import { EQ, GT, LT } from "Compare"
import Float from "Float"
import Fn from "Function"
import IO from "IO"
import List from "List"
import Math from "Math"
import Maybe from "Maybe"

import Random from "Random"



// import Random from "Random"



export type Suit
  = Pine
  | Plum
  | Cherry
  | Wisteria
  | Iris
  | Peony
  | Clover
  | Grass
  | Chrysanthemum
  | Maple
  | Willow
  | Foxglove

type CardState = Pile | Up | Held | Played | Discarded
type PlayingCard = PlayingCard(CardState, Card)



// Hikari = 20
// Tane = 5
// Tanzaku = 10
// Kasu = 0
export type Value = Hikari | Tane | Tanzaku | Kasu
export type Card = Card(Suit, Value)

type Player = Player(String, List Card)


export NAMED = {
  crane: Card(Pine, Hikari),
  warbler: Card(Plum, Tane),
  sakura: Card(Cherry, Hikari),
  songbird: Card(Wisteria, Tane),
  bridge: Card(Iris, Tane),
  butterflies: Card(Peony, Tane),
  pig: Card(Clover, Tane),
  moon: Card(Grass, Hikari),
  birds: Card(Grass, Tanzaku),
  sake: Card(Chrysanthemum, Tane),
  deer: Card(Maple, Tane),
  police: Card(Willow, Kasu),
  rainman: Card(Willow, Tane),
  swallow: Card(Willow, Tane),
  chicken: Card(Foxglove, Hikari),
  foxglove: Card(Foxglove, Tanzaku),
}

export BANNERS = {
  pine: Card(Pine, Tanzaku),
  plum: Card(Plum, Tanzaku),
  cherry: Card(Cherry, Tanzaku),
  wisteria: Card(Wisteria, Tanzaku),
  iris: Card(Iris, Tanzaku),
  grass: Card(Grass, Tanzaku),
  peony: Card(Peony, Tanzaku),
  clover: Card(Clover, Tanzaku),
  chrysanthemum: Card(Chrysanthemum, Tanzaku),
  maple: Card(Maple, Tanzaku),
  willow: Card(Willow, Tanzaku),
}


DECK :: List Card
export DECK = [
  NAMED.crane,
  BANNERS.pine,
  Card(Pine, Kasu),
  Card(Pine, Kasu),
  NAMED.warbler,
  BANNERS.plum,
  Card(Plum, Kasu),
  Card(Plum, Kasu),
  NAMED.sakura,
  BANNERS.cherry,
  Card(Cherry, Kasu),
  Card(Cherry, Kasu),
  NAMED.songbird,
  BANNERS.wisteria,
  Card(Wisteria, Kasu),
  Card(Wisteria, Kasu),
  NAMED.bridge,
  BANNERS.iris,
  Card(Iris, Kasu),
  Card(Iris, Kasu),
  NAMED.butterflies,
  BANNERS.peony,
  Card(Peony, Kasu),
  Card(Peony, Kasu),
  NAMED.pig,
  BANNERS.clover,
  Card(Clover, Kasu),
  Card(Clover, Kasu),
  NAMED.moon,
  BANNERS.grass,
  Card(Grass, Kasu),
  Card(Grass, Kasu),
  NAMED.sake,
  BANNERS.chrysanthemum,
  Card(Chrysanthemum, Kasu),
  Card(Chrysanthemum, Kasu),
  NAMED.deer,
  BANNERS.maple,
  Card(Maple, Kasu),
  Card(Maple, Kasu),
  NAMED.rainman,
  NAMED.swallow,
  BANNERS.willow,
  NAMED.police,
  NAMED.chicken,
  NAMED.foxglove,
  Card(Foxglove, Kasu),
  Card(Foxglove, Kasu),
]

export alias Yaku = #[Card, Card, Card]

// these are sorted by month order 
export YAKUS = [
  #[NAMED.crane, NAMED.sakura, NAMED.warbler],
  #[NAMED.sakura, NAMED.moon, NAMED.sake],
  #[NAMED.butterflies, NAMED.sake, NAMED.deer],
  #[NAMED.pig, NAMED.birds, NAMED.deer],
  #[NAMED.songbird, NAMED.bridge, NAMED.pig],
  #[BANNERS.pine, BANNERS.plum, BANNERS.cherry],
  #[BANNERS.wisteria, BANNERS.iris, BANNERS.clover],
  #[BANNERS.peony, BANNERS.chrysanthemum, BANNERS.maple],
]

hasCard :: Card -> List Card -> Boolean
hasCard = (c, cs) => Fn.any(
  (k) => where(#[c, k]) {
    #[Card(a, a2), Card(b, b2)] =>
      a == b && a2 == b2
  },
  cs,
)

checkYaku :: Yaku -> List Card -> Boolean
checkYaku = (yaku, cards) => {
  sorted = sortCards(cards)
  return where(yaku) {
    #[a, b, c] =>
      Fn.all(hasCard($, cards), [a, b, c])
  }
}

hasYaku :: List Card -> Boolean
hasYaku = (cards) => Fn.any(checkYaku($, cards), YAKUS)

// assumes that the yaku is valid and sorted
pointsForYaku :: Yaku -> Integer
export pointsForYaku = where {
  #[_, Card(Cherry, Hikari), _] =>
    100

  #[Card(Cherry, Hikari), _, _] =>
    100

  _ =>
    50
}

toPointValue :: Value -> Integer
toPointValue = where {
  Hikari =>
    20

  Tanzaku =>
    10

  Tane =>
    5

  _ =>
    0
}

toOrdinalMonth :: Suit -> Integer
toOrdinalMonth = where {
  Pine =>
    0

  Plum =>
    1

  Cherry =>
    2

  Wisteria =>
    3

  Iris =>
    4

  Peony =>
    5

  Clover =>
    6

  Grass =>
    7

  Chrysanthemum =>
    8

  Maple =>
    9

  Willow =>
    10

  Foxglove =>
    11
}


sortCards :: List Card -> List Card
sortCards = List.sortBy(
  (a, b) => where(#[a, b]) {
    #[Card(s1, v1), Card(s2, v2)] =>
      do {
        x = toOrdinalMonth(s1)
        x2 = toPointValue(v1)
        y = toOrdinalMonth(s2)
        y2 = toPointValue(v1)
        return if (x == y) {
          x2 == y2 ? EQ : x2 < y2 ? GT : LT
        } else {
          x > y ? GT : LT
        }
      }
  },
)

numberOfCardsByNumberOfPlayers :: Integer -> #[Integer, Integer]
numberOfCardsByNumberOfPlayers = (i) => i == 2
  ? #[8, 8]
  : i == 3
    ? #[7, 6]
    : i == 4 ? #[5, 8] : i == 5 ? #[4, 8] : i == 6 ? #[3, 12] : i == 7 ? #[3, 6] : #[-1, -1]

playerAtIndex :: Integer -> List Player -> Player
playerAtIndex = (i, players) => pipe(
  List.nth(i),
  Maybe.fromMaybe(Player("Nobody", [])),
)(players)

playerName :: Player -> String
playerName = where {
  Player(name, _) =>
    name
}

nameOfPlayerAtIndex :: List Player -> Integer -> String
nameOfPlayerAtIndex = (players, i) => pipe(
  playerAtIndex(i),
  playerName,
)(players)

cut :: Integer -> List a -> #[List a, List a]
cut = (a, xs) => #[List.slice(0, a, xs), List.slice(a, List.length(xs), xs)]

segment :: Integer -> List a -> List (List a)
segment = (l, xs) => {
  t = List.length(xs)
  perfect = t % l == 0
  whole = Float.toInteger(Math.floor(t / l))
  repeat = perfect ? whole : whole + 1
  return l < 1 ? [xs] : List.repeatWith((i) => List.slice(i * l, (i + 1) * l, xs), repeat)
}


alias DealtState = { pile :: List Card, players :: List Player, visible :: List Card }

deal :: String -> List Card -> List String -> DealtState
deal = (seed, allCards, playerNames) => {
  rand = Random.generateFromString(seed)
  shuffled = rand.shuffle(allCards)
  totalPlayers = List.length(playerNames)
  return if (totalPlayers < 2 || totalPlayers > 7) {
    { pile: [], players: [], visible: [] }
  } else {
    where(numberOfCardsByNumberOfPlayers(totalPlayers)) {
      #[perPlayer, faceUp] =>
        pipe(
          segment(perPlayer),
          cut(totalPlayers),
          where {
            #[dealt, rest] =>
              pipe(
                List.flatten,
                cut(faceUp),
                where {
                  #[upCards, pile] =>
                    (
                      {
                        players: pipe(
                          List.zip(playerNames),
                          map(where { #[n, c] => Player(n, sortCards(c)) }),
                        )(dealt),
                        visible: sortCards(upCards),
                        pile,
                      }
                    )
                },
              )(rest)
          },
        )(shuffled)
    }
  }
}

// round :: GameState -> GameState
// round = (state) => {}

main = () => {
  dealt = deal("flower-cards-v1", DECK, ["Brekk", "Clive"])
  IO.pLog(dealt)
  map(
    where {
      Player(name, cards) =>
        IO.trace(`${name} has chicken?`, hasCard(NAMED.chicken, cards))
    },
    dealt.players,
  )
  checkYaku(
    #[NAMED.crane, NAMED.sakura, NAMED.warbler],
    [NAMED.sakura, NAMED.warbler, NAMED.moon, NAMED.crane],
  )
    |> IO.trace("YAKU CHECK!")

  hasYaku([NAMED.sakura, NAMED.warbler, NAMED.crane]) |> IO.trace("magic!")
}
